/**
 * Git Manager
 * Handles git operations for project
 */

const simpleGit = require('simple-git');
const fs = require('fs-extra');
const path = require('path');
const { FileSystemError } = require('../utils/errors');

class GitManager {
  constructor(outputDir) {
    this.outputDir = outputDir;
    this.git = simpleGit(outputDir);
  }

  /**
   * Initialize git repository
   * @returns {Promise<boolean>}
   */
  async initialize() {
    try {
      // Check if already a git repo
      const isRepo = await this.git.checkIsRepo();

      if (isRepo) {
        return false; // Already initialized
      }

      // Initialize
      await this.git.init();

      // Create .gitignore if it doesn't exist
      await this._createGitignore();

      return true;
    } catch (error) {
      throw new FileSystemError(
        `Failed to initialize git: ${error.message}`,
        { outputDir: this.outputDir, error: error.message }
      );
    }
  }

  /**
   * Create initial commit
   * @param {string} message
   * @returns {Promise<string>} commit hash
   */
  async createInitialCommit(message = 'Initial commit - project structure') {
    try {
      await this.git.add('.');
      const result = await this.git.commit(message);
      return result.commit;
    } catch (error) {
      throw new FileSystemError(
        `Failed to create initial commit: ${error.message}`,
        { error: error.message }
      );
    }
  }

  /**
   * Commit changes for a task
   * @param {Object} task
   * @param {Array} files
   * @returns {Promise<string>} commit hash
   */
  async commitTask(task, files) {
    try {
      // SECURITY: Validate .gitignore before committing
      await this._validateGitignore();

      // SECURITY: Check for sensitive data in files being committed
      if (files && files.length > 0) {
        const sensitiveFiles = this._detectSensitiveFiles(files);
        if (sensitiveFiles.length > 0) {
          throw new FileSystemError(
            `Security: Attempting to commit sensitive files: ${sensitiveFiles.join(', ')}. ` +
            'Please add these patterns to .gitignore.',
            {
              sensitiveFiles,
              securityIssue: 'sensitive_data_detected'
            }
          );
        }
      }

      // Add files
      if (files && files.length > 0) {
        await this.git.add(files);
      } else {
        await this.git.add('.');
      }

      // Check if there are changes to commit
      const status = await this.git.status();
      if (status.staged.length === 0) {
        return null; // Nothing to commit
      }

      // Create descriptive commit message
      const message = this._formatCommitMessage(task, files);

      const result = await this.git.commit(message);
      return result.commit;
    } catch (error) {
      throw new FileSystemError(
        `Failed to commit task: ${error.message}`,
        { taskId: task.id, error: error.message }
      );
    }
  }

  /**
   * Get repository status
   * @returns {Promise<Object>}
   */
  async getStatus() {
    try {
      const status = await this.git.status();
      return {
        branch: status.current,
        staged: status.staged,
        modified: status.modified,
        created: status.created,
        deleted: status.deleted,
        untracked: status.not_added,
        ahead: status.ahead,
        behind: status.behind
      };
    } catch (error) {
      throw new FileSystemError(
        `Failed to get git status: ${error.message}`,
        { error: error.message }
      );
    }
  }

  /**
   * Get commit history
   * @param {number} limit
   * @returns {Promise<Array>}
   */
  async getHistory(limit = 10) {
    try {
      const log = await this.git.log({ maxCount: limit });
      return log.all.map(commit => ({
        hash: commit.hash,
        message: commit.message,
        author: commit.author_name,
        date: commit.date
      }));
    } catch (error) {
      throw new FileSystemError(
        `Failed to get commit history: ${error.message}`,
        { error: error.message }
      );
    }
  }

  /**
   * Check if repository is clean
   * @returns {Promise<boolean>}
   */
  async isClean() {
    try {
      const status = await this.git.status();
      return status.isClean();
    } catch (error) {
      return false;
    }
  }

  /**
   * Format commit message for task
   * @private
   */
  _formatCommitMessage(task, files) {
    const taskType = this._inferTaskType(task);
    const scope = this._inferScope(files);

    // Conventional commit format
    let message = `${taskType}`;

    if (scope) {
      message += `(${scope})`;
    }

    message += `: ${task.name || task.description}`;

    // Add details
    if (files && files.length > 0) {
      message += `\n\nFiles modified:\n${files.map(f => `- ${f}`).join('\n')}`;
    }

    // Add agent info
    if (task.agentType) {
      message += `\n\nGenerated by: ${task.agentType}`;
    }

    return message;
  }

  /**
   * Infer task type from description
   * @private
   */
  _inferTaskType(task) {
    const description = (task.description || task.name || '').toLowerCase();

    if (description.includes('fix') || description.includes('bug')) {
      return 'fix';
    }
    if (description.includes('test')) {
      return 'test';
    }
    if (description.includes('doc')) {
      return 'docs';
    }
    if (description.includes('refactor')) {
      return 'refactor';
    }
    if (description.includes('style') || description.includes('format')) {
      return 'style';
    }
    if (description.includes('performance') || description.includes('optimize')) {
      return 'perf';
    }

    // Default to feat for new features
    return 'feat';
  }

  /**
   * Infer scope from files
   * @private
   */
  _inferScope(files) {
    if (!files || files.length === 0) {
      return null;
    }

    // Get common directory
    const dirs = files.map(f => path.dirname(f));
    const uniqueDirs = [...new Set(dirs)];

    if (uniqueDirs.length === 1 && uniqueDirs[0] !== '.') {
      return uniqueDirs[0].split('/')[0];
    }

    // Infer from file types
    const hasTests = files.some(f => f.includes('test') || f.includes('spec'));
    if (hasTests) {
      return 'tests';
    }

    const hasAPI = files.some(f => f.includes('api') || f.includes('controller'));
    if (hasAPI) {
      return 'api';
    }

    const hasDB = files.some(f => f.includes('model') || f.includes('schema'));
    if (hasDB) {
      return 'database';
    }

    return null;
  }

  /**
   * Create default .gitignore
   * @private
   */
  async _createGitignore() {
    const gitignorePath = path.join(this.outputDir, '.gitignore');

    if (await fs.pathExists(gitignorePath)) {
      return;
    }

    const defaultGitignore = `# Dependencies
node_modules/
venv/
__pycache__/

# Environment
.env
.env.local
.env.*
*.local

# Secrets and credentials
*secret*
*password*
*token*
*api_key*
*apikey*
credentials.json
*.pem
*.key
*.cert

# Build
dist/
build/
*.egg-info/

# IDE
.vscode/
.idea/
*.swp

# OS
.DS_Store
Thumbs.db

# CodeSwarm
.codeswarm/
*-backup/

# Logs
*.log
logs/
`;

    await fs.writeFile(gitignorePath, defaultGitignore, 'utf-8');
  }

  /**
   * Validate .gitignore has essential security patterns
   * @private
   */
  async _validateGitignore() {
    const gitignorePath = path.join(this.outputDir, '.gitignore');

    if (!await fs.pathExists(gitignorePath)) {
      // Create default gitignore if missing
      await this._createGitignore();
      return;
    }

    const gitignoreContent = await fs.readFile(gitignorePath, 'utf-8');

    // Critical patterns that must be in .gitignore
    const criticalPatterns = [
      { pattern: /\.env/i, name: '.env files' },
      { pattern: /node_modules/i, name: 'node_modules' },
      { pattern: /\*\.log/i, name: 'log files' }
    ];

    const missingPatterns = criticalPatterns.filter(
      p => !p.pattern.test(gitignoreContent)
    );

    if (missingPatterns.length > 0) {
      console.warn(
        '[GitManager] Warning: .gitignore missing critical patterns:',
        missingPatterns.map(p => p.name).join(', ')
      );
    }
  }

  /**
   * Detect sensitive files that shouldn't be committed
   * @private
   */
  _detectSensitiveFiles(files) {
    const sensitivePatterns = [
      /\.env$/i,
      /\.env\./i,
      /secret/i,
      /password/i,
      /token/i,
      /api[_-]?key/i,
      /credentials\.json$/i,
      /\.pem$/i,
      /\.key$/i,
      /\.cert$/i,
      /private[_-]?key/i,
      /id_rsa/i,
      /\.ssh\//i,
      /aws[_-]?credentials/i,
      /\.npmrc$/i,
      /\.pypirc$/i
    ];

    return files.filter(file => {
      return sensitivePatterns.some(pattern => pattern.test(file));
    });
  }
}

module.exports = GitManager;
